{"expireTime":9007200804686346000,"key":"transformer-remark-markdown-html-f1073de8ef67a090f9a6772eb6246608-gatsby-remark-graphvizgatsby-remark-code-titlesgatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<p>This document aims to outline how resources are fetched and cached by various parts of Gatsby.</p>\n<h2 id=\"offline-plugin-gatsby-plugin-offline\"><a href=\"#offline-plugin-gatsby-plugin-offline\" aria-label=\"offline plugin gatsby plugin offline permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Offline Plugin (gatsby-plugin-offline)</h2>\n<h3 id=\"service-worker-swjs\"><a href=\"#service-worker-swjs\" aria-label=\"service worker swjs permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Service worker (<code class=\"language-text\">sw.js</code>)</h3>\n<p>In the offline plugin, we specify which types of files should be automatically cached at runtime (i.e. resource files) so that whenever these are fetched from the network, they are saved in the cache.</p>\n<p>We also keep an array stored in the IndexedDB which keeps a list of page paths (e.g. <code class=\"language-text\">/about/</code>) whose resources have all been cached. For these paths, we serve the offline shell rather than the full HTML, because we know that their resources are readily available (even if offline). For paths which aren’t in this array, we load the HTML from the server as usual, which allows for native offline error pages to be displayed if the network is offline and allows static HTML to be rendered if the JS resources fail for some reason (e.g. due to an adblocker false-positive).</p>\n<p>It’s important that this array is accurate - if a page entered the array when its resources hadn’t actually been cached, then the page could appear blank when loaded if the site updated in the meantime. A problem with the current approach is that devices may automatically remove cached files if they’re running out of space, while the IDB array would still report these pages as being cached - in the future we aim to handle this behavior.</p>\n<h3 id=\"browser-apis-gatsby-browserjs\"><a href=\"#browser-apis-gatsby-browserjs\" aria-label=\"browser apis gatsby browserjs permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Browser APIs (<code class=\"language-text\">gatsby-browser.js</code>)</h3>\n<p>When all resources for a page have been successfully prefetched, we do <em>one</em> of the following:</p>\n<ul>\n<li>Add the page’s path to a temporary array of prefetched paths, if the service worker has not yet installed</li>\n<li>Send a message to the service worker to let it know to whitelist the page’s path, if it is installed</li>\n</ul>\n<p>Upon initial install, we do the following:</p>\n<ul>\n<li>Loop through all scripts and stylesheets in the head and fetch these again, so that Workbox can now cache them</li>\n<li>Fetch all resources for pages whose paths are in the temporary prefetched paths array, so that Workbox can now cache them</li>\n</ul>\n<p>Note that in both of the above cases, all these files should have already been downloaded once by the browser, so with <a href=\"/docs/caching/\">proper HTTP caching setup</a> we don’t have to download any of the files again. However, one exception to this is <code class=\"language-text\">&lt;style&gt;</code> elements with a <code class=\"language-text\">data-href</code> attribute (indicating that the embedded stylesheet is the same as the stylesheet at the location specified) - we currently fetch the specified file rather than caching the contents of the element.</p>\n<p>Another current problem is that we may start fetching the resources for a page before the service worker has finished installing, but finish fetching them all after it has installed - this could cause a page’s path to be whitelisted even if some of its resources haven’t been cached (since Gatsby assumes the service worker was installed at the start of fetching resources, if it was installed at the end).</p>\n<h2 id=\"gatsby-core\"><a href=\"#gatsby-core\" aria-label=\"gatsby core permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gatsby Core</h2>\n<h3 id=\"resource-loader-loaderjs\"><a href=\"#resource-loader-loaderjs\" aria-label=\"resource loader loaderjs permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Resource loader (<code class=\"language-text\">loader.js</code>)</h3>\n<p>There are two functions which perform a similar but distinct role in this file: <code class=\"language-text\">enqueue</code> and <code class=\"language-text\">getResourcesForPathname</code>. The former of these, <code class=\"language-text\">enqueue</code>, is designed to speed up navigation by prefetching resources for a page, before we need to display the page, and hence it doesn’t return anything. On the other hand, <code class=\"language-text\">getResourcesForPathname</code> is used when we need the resources right now, usually in order to display the page, and therefore it fetches with higher priority than <code class=\"language-text\">enqueue</code> as well as returning them. Another difference between the two is that <code class=\"language-text\">getResourcesForPathname</code> returns the resources for the 404 page if the specified page doesn’t exist.</p>\n<p>In the future, we could refactor these into a single function which takes parameters for whether or not to return the 404 page if the specified page is missing, and for whether to fetch with high or low priority.</p>\n<h3 id=\"ensureresources-ensure-resourcesjs\"><a href=\"#ensureresources-ensure-resourcesjs\" aria-label=\"ensureresources ensure resourcesjs permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>EnsureResources (<code class=\"language-text\">ensure-resources.js</code>)</h3>\n<p>The <code class=\"language-text\">EnsureResources</code> component exists to (as its name suggest) ensure that we have the resources for a specified page, and load them if we currently don’t. There are some valid reasons why we might not have resources at the time of navigation:</p>\n<ol>\n<li>404s resulting from site-internal links, when the user has not created a custom 404 page with <code class=\"language-text\">404.js</code></li>\n<li>When visiting a page (which hasn’t been visited before), the site may have been updated since our last navigation and so the resources to the unvisited page may have changed location</li>\n<li>Ad blockers may block access to certain paths in which case we’re unable to load the JS resources for a page</li>\n</ol>\n<p>Here is how the <code class=\"language-text\">EnsureResources</code> component handles each of these scenarios:</p>\n<ol>\n<li>\n<p>On non-initial renders, reload upon missing resources so that the browser can load the server’s 404 page</p>\n</li>\n<li>\n<p>On initial renders, flag the page as failed and throw an error to prevent rendering a blank page (static HTML will suffice), then reload it once the service worker updates</p>\n<p>On non-initial renders, reload upon missing resources so that the browser can load the latest page</p>\n</li>\n<li>\n<p>On initial renders, throw an error to prevent rendering a blank page (static HTML will suffice)</p>\n</li>\n</ol>\n<p>The following are some invalid reasons why we might not have resources, i.e. things which we should never have to worry about:</p>\n<ol>\n<li>404s from external links, without a custom 404 page - the page will load from the server in the first place, so Gatsby won’t even kick in at this point</li>\n<li>404s, with a custom 404 page - <code class=\"language-text\">getResourcesForPathname</code> will automatically return the resources for the custom 404 page</li>\n<li>Visiting a previously-visited page via an external link, when the site’s resources have since updated - previously-visited pages are cached, so they’ll work even if the site has updated since. Unvisited pages will always load from the server and get the latest resources.</li>\n</ol>\n<h3 id=\"service-worker-update-handling\"><a href=\"#service-worker-update-handling\" aria-label=\"service worker update handling permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Service worker update handling</h3>\n<p>The service worker updates automatically when the browser detects that the contents of the <code class=\"language-text\">sw.js</code> file have changed from the currently installed version. Upon an update, we clear all whitelisted paths to prevent old pages from loading after the update.</p>\n<p>Blank pages can theoretically occur if we serve the app shell when resources are unavailable - however, this <em>should</em> never occur since we only serve the app shell with whitelisted paths (i.e. ones whose resources have been cached entirely). There may be some edge cases when this can occur, e.g. when the Webpack runtime from the old site attepmts to load a chunk which is unavailable on the updated site - we are currently investigating ways to prevent this, and make using service workers with Gatsby even more robust.</p>\n<p>We should also never get incorrect 404 pages following a site update, since we never whitelist 404 pages to serve using the offline shell, meaning that a page which was previously a 404 should always load from the server. If it’s no longer a 404, then it will be cached as usual.</p>"}