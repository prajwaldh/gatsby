{"expireTime":9007200804686346000,"key":"transformer-remark-markdown-html-32f66db6a3cc7a1734bfa48c134b73b0-gatsby-remark-graphvizgatsby-remark-code-titlesgatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<h2 id=\"what-are-schema-connections\"><a href=\"#what-are-schema-connections\" aria-label=\"what are schema connections permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What are schema connections?</h2>\n<p>So far in schema generation, we have covered how <a href=\"/docs/schema-gql-type\">GraphQL types are inferred</a>, how <a href=\"/docs/schema-input-gql\">query arguments for types</a> are created, and how <a href=\"/docs/schema-sift\">sift resolvers</a> work. But all of these only allow querying down to a single node of a type. Schema connections is the ability to query over <strong>collections</strong> of nodes of a type. For example, if we want to query all markdown nodes by some criteria, it will allow us to write queries such as:</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token punctuation\">{</span>\n  allMarkdownRemark<span class=\"token punctuation\">(</span><span class=\"token attr-name\">filter</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token attr-name\">frontmatter</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token attr-name\">tags</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token attr-name\">in</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"wordpress\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    edges <span class=\"token punctuation\">{</span>\n      node <span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">...</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Other features covered by schema connections are aggregators and reducers such as <code class=\"language-text\">distinct</code>, <code class=\"language-text\">group</code> and <code class=\"language-text\">totalCount</code>, <code class=\"language-text\">edges</code>, <code class=\"language-text\">skip</code>, <code class=\"language-text\">limit</code>, and more.</p>\n<h3 id=\"connectionedge\"><a href=\"#connectionedge\" aria-label=\"connectionedge permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Connection/Edge</h3>\n<p>A connection is an abstraction that describes a collection of nodes of a type, and how to query and navigate through them. In the above example query, <code class=\"language-text\">allMarkdownRemark</code> is a Connection Type. Its field <code class=\"language-text\">edges</code> is analogous to <code class=\"language-text\">results</code>. Each Edge points at a <code class=\"language-text\">node</code> (in the collection of all markdownRemark nodes), but it also points to the logical <code class=\"language-text\">next</code> and <code class=\"language-text\">previous</code> nodes, relative to the <code class=\"language-text\">node</code> in the collection (meaningful if you provided a <code class=\"language-text\">sort</code> arg).</p>\n<p><em>Fun Fact: This stuff is all based on <a href=\"https://facebook.github.io/relay/graphql/connections.htm\">relay connections</a> concepts</em></p>\n<p>The ConnectionType also defines input args to perform paging using the <code class=\"language-text\">skip/limit</code> pattern. The actual logic for paging is defined in the <a href=\"https://www.npmjs.com/package/graphql-skip-limit\">graphql-skip-limit</a> library in <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/graphql-skip-limit/src/connection/arrayconnection.js\">arrayconnection.js</a>. It is invoked as the last part of the <a href=\"/docs/schema-sift#5-run-sift-query-on-all-nodes\">run-sift</a> function. To aid in paging, the ConnectionType also defines a <code class=\"language-text\">pageInfo</code> field with a <code class=\"language-text\">hasNextPage</code> field.</p>\n<p>The ConnectionType is defined in the <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/graphql-skip-limit/src/connection/connection.js\">graphql-skip-limit connection.js</a> file. Its construction function takes a Type, and uses it to create a connectionType. E.g passing in <code class=\"language-text\">MarkdownRemark</code> Type would result in a <code class=\"language-text\">MarkdownRemarkConnection</code> type whose <code class=\"language-text\">edges</code> field would be of type <code class=\"language-text\">MarkdownRemarkEdge</code>.</p>\n<h3 id=\"groupconnection\"><a href=\"#groupconnection\" aria-label=\"groupconnection permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GroupConnection</h3>\n<p>A GroupConnection is a Connection with extended functionality. Instead of simply providing the means to access nodes in a collection, it allows you to group those nodes by one of its fields. It <em>is</em> a <code class=\"language-text\">Connection</code> Type itself, but with 3 new fields: <code class=\"language-text\">field</code>, <code class=\"language-text\">fieldValue</code>, and <code class=\"language-text\">totalCount</code>. It adds a new input argument to <code class=\"language-text\">ConnectionType</code> whose value can be any (possibly nested) field on the original type.</p>\n<p>The creation of the GroupConnection is handled in <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/build-connection-fields.js#L57\">build-connection-fields.js</a>. It’s added as the <code class=\"language-text\">group</code> field to the top level type connection. This is most easily shown in the below diagram.</p>\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Generated by graphviz version 2.40.1 (20161225.0304)\n -->\n<!-- Title: structs Pages: 1 -->\n<svg width=\"486pt\" height=\"497pt\"\n viewBox=\"0.00 0.00 485.64 496.60\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 492.6)\">\n<title>structs</title>\n<polygon fill=\"#ffffff\" stroke=\"transparent\" points=\"-4,4 -4,-492.6 481.6408,-492.6 481.6408,4 -4,4\"/>\n<!-- mdConn -->\n<g id=\"node1\" class=\"node\">\n<title>mdConn</title>\n<path fill=\"none\" stroke=\"#000000\" d=\"M112.1101,-322.5C112.1101,-322.5 274.4005,-322.5 274.4005,-322.5 280.4005,-322.5 286.4005,-328.5 286.4005,-334.5 286.4005,-334.5 286.4005,-476.1 286.4005,-476.1 286.4005,-482.1 280.4005,-488.1 274.4005,-488.1 274.4005,-488.1 112.1101,-488.1 112.1101,-488.1 106.1101,-488.1 100.1101,-482.1 100.1101,-476.1 100.1101,-476.1 100.1101,-334.5 100.1101,-334.5 100.1101,-328.5 106.1101,-322.5 112.1101,-322.5\"/>\n<text text-anchor=\"start\" x=\"108.1101\" y=\"-471.5\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">MarkdownRemarkConnection</text>\n<text text-anchor=\"middle\" x=\"193.2553\" y=\"-454.7\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\"> (allMarkdownRemark)</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"100.1101,-446.5 286.4005,-446.5 \"/>\n<text text-anchor=\"middle\" x=\"193.2553\" y=\"-429.9\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">pageInfo</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"100.1101,-421.7 286.4005,-421.7 \"/>\n<text text-anchor=\"middle\" x=\"193.2553\" y=\"-405.1\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">edges</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"100.1101,-396.9 286.4005,-396.9 \"/>\n<text text-anchor=\"middle\" x=\"193.2553\" y=\"-380.3\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">group</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"100.1101,-372.1 286.4005,-372.1 \"/>\n<text text-anchor=\"middle\" x=\"193.2553\" y=\"-355.5\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">distinct</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"100.1101,-347.3 286.4005,-347.3 \"/>\n<text text-anchor=\"middle\" x=\"193.2553\" y=\"-330.7\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">totalCount</text>\n</g>\n<!-- mdEdge -->\n<g id=\"node2\" class=\"node\">\n<title>mdEdge</title>\n<path fill=\"none\" stroke=\"#000000\" d=\"M12,-161.5C12,-161.5 138.5106,-161.5 138.5106,-161.5 144.5106,-161.5 150.5106,-167.5 150.5106,-173.5 150.5106,-173.5 150.5106,-248.7 150.5106,-248.7 150.5106,-254.7 144.5106,-260.7 138.5106,-260.7 138.5106,-260.7 12,-260.7 12,-260.7 6,-260.7 0,-254.7 0,-248.7 0,-248.7 0,-173.5 0,-173.5 0,-167.5 6,-161.5 12,-161.5\"/>\n<text text-anchor=\"middle\" x=\"75.2553\" y=\"-244.1\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">MarkdownRemarkEdge</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"0,-235.9 150.5106,-235.9 \"/>\n<text text-anchor=\"middle\" x=\"75.2553\" y=\"-219.3\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">node</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"0,-211.1 150.5106,-211.1 \"/>\n<text text-anchor=\"middle\" x=\"75.2553\" y=\"-194.5\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">next</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"0,-186.3 150.5106,-186.3 \"/>\n<text text-anchor=\"middle\" x=\"75.2553\" y=\"-169.7\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">previous</text>\n</g>\n<!-- mdConn&#45;&gt;mdEdge -->\n<g id=\"edge2\" class=\"edge\">\n<title>mdConn:edges&#45;&gt;mdEdge</title>\n<path fill=\"none\" stroke=\"#000000\" d=\"M100.2553,-409.3C43.782,-409.3 49.0348,-329.115 60.3385,-270.7492\"/>\n<polygon fill=\"#000000\" stroke=\"#000000\" points=\"63.7868,-271.3554 62.3502,-260.8584 56.9272,-269.9601 63.7868,-271.3554\"/>\n</g>\n<!-- mdGroupConn -->\n<g id=\"node3\" class=\"node\">\n<title>mdGroupConn</title>\n<path fill=\"none\" stroke=\"#000000\" d=\"M180.953,-136.7C180.953,-136.7 443.5576,-136.7 443.5576,-136.7 449.5576,-136.7 455.5576,-142.7 455.5576,-148.7 455.5576,-148.7 455.5576,-273.5 455.5576,-273.5 455.5576,-279.5 449.5576,-285.5 443.5576,-285.5 443.5576,-285.5 180.953,-285.5 180.953,-285.5 174.953,-285.5 168.953,-279.5 168.953,-273.5 168.953,-273.5 168.953,-148.7 168.953,-148.7 168.953,-142.7 174.953,-136.7 180.953,-136.7\"/>\n<text text-anchor=\"middle\" x=\"312.2553\" y=\"-268.9\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">MarkdownRemarkGroupConnectionConnection</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"168.953,-260.7 455.5576,-260.7 \"/>\n<text text-anchor=\"middle\" x=\"312.2553\" y=\"-244.1\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">pageInfo</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"168.953,-235.9 455.5576,-235.9 \"/>\n<text text-anchor=\"middle\" x=\"312.2553\" y=\"-219.3\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">edges</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"168.953,-211.1 455.5576,-211.1 \"/>\n<text text-anchor=\"middle\" x=\"312.2553\" y=\"-194.5\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">field</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"168.953,-186.3 455.5576,-186.3 \"/>\n<text text-anchor=\"middle\" x=\"312.2553\" y=\"-169.7\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">fieldValue</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"168.953,-161.5 455.5576,-161.5 \"/>\n<text text-anchor=\"middle\" x=\"312.2553\" y=\"-144.9\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">totalCount</text>\n</g>\n<!-- mdConn&#45;&gt;mdGroupConn -->\n<g id=\"edge1\" class=\"edge\">\n<title>mdConn:group&#45;&gt;mdGroupConn</title>\n<path fill=\"none\" stroke=\"#000000\" d=\"M286.2553,-384.3C325.8311,-384.3 331.8852,-339.5289 328.274,-295.512\"/>\n<polygon fill=\"#000000\" stroke=\"#000000\" points=\"331.7572,-295.1688 327.2991,-285.5576 324.7906,-295.8511 331.7572,-295.1688\"/>\n</g>\n<!-- mdGroupConnEdge -->\n<g id=\"node4\" class=\"node\">\n<title>mdGroupConnEdge</title>\n<path fill=\"none\" stroke=\"#000000\" d=\"M198.8429,-.5C198.8429,-.5 425.6677,-.5 425.6677,-.5 431.6677,-.5 437.6677,-6.5 437.6677,-12.5 437.6677,-12.5 437.6677,-87.7 437.6677,-87.7 437.6677,-93.7 431.6677,-99.7 425.6677,-99.7 425.6677,-99.7 198.8429,-99.7 198.8429,-99.7 192.8429,-99.7 186.8429,-93.7 186.8429,-87.7 186.8429,-87.7 186.8429,-12.5 186.8429,-12.5 186.8429,-6.5 192.8429,-.5 198.8429,-.5\"/>\n<text text-anchor=\"middle\" x=\"312.2553\" y=\"-83.1\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">MarkdownRemarkGroupConnectionEdge</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"186.8429,-74.9 437.6677,-74.9 \"/>\n<text text-anchor=\"middle\" x=\"312.2553\" y=\"-58.3\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">node</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"186.8429,-50.1 437.6677,-50.1 \"/>\n<text text-anchor=\"middle\" x=\"312.2553\" y=\"-33.5\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">next</text>\n<polyline fill=\"none\" stroke=\"#000000\" points=\"186.8429,-25.3 437.6677,-25.3 \"/>\n<text text-anchor=\"middle\" x=\"312.2553\" y=\"-8.7\" font-family=\"Times,serif\" font-size=\"14.00\" fill=\"#000000\">previous</text>\n</g>\n<!-- mdGroupConn&#45;&gt;mdGroupConnEdge -->\n<g id=\"edge3\" class=\"edge\">\n<title>mdGroupConn:edges&#45;&gt;mdGroupConnEdge</title>\n<path fill=\"none\" stroke=\"#000000\" d=\"M455.2553,-223.1C493.8775,-223.1 474.2585,-169.8237 455.2553,-136.2 448.9548,-125.0521 440.5689,-115.1874 431.0052,-106.4951\"/>\n<polygon fill=\"#000000\" stroke=\"#000000\" points=\"432.9856,-103.5848 423.1001,-99.7733 428.451,-108.9176 432.9856,-103.5848\"/>\n</g>\n</g>\n</svg>\n\n<p>Let’s see this in practice. Say we were trying to group all markdown nodes by their author. We would query the top level <code class=\"language-text\">MarkdownRemarkConnection</code> (<code class=\"language-text\">allMarkdownRemark</code>) which would return a <code class=\"language-text\">MarkdownRemarkConnection</code> with this new group input argument, which would return a <code class=\"language-text\">MarkdownRemarkGroupConnectionConnection</code> field. E.g:</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token punctuation\">{</span>\n  allMarkdownRemark <span class=\"token punctuation\">{</span>\n    group<span class=\"token punctuation\">(</span><span class=\"token attr-name\">field</span><span class=\"token punctuation\">:</span> frontmatter___author<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      fieldValue\n      edges <span class=\"token punctuation\">{</span>\n        node <span class=\"token punctuation\">{</span>\n          frontmatter <span class=\"token punctuation\">{</span>\n            title\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4 id=\"field-enum-value\"><a href=\"#field-enum-value\" aria-label=\"field enum value permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Field enum value</h4>\n<p>The <code class=\"language-text\">frontmatter___author</code> value is interesting. It describes a nested field. I.e, we want to group all markdown nodes by their <code class=\"language-text\">frontmatter.author</code> field. The author field in each frontmatter subobject. So why not use a period? The problem is that GraphQL doesn’t allow periods in fields names, so we instead use <code class=\"language-text\">___</code>, and then in the <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/build-connection-fields.js#L69\">resolver</a>, we convert it back to a period.</p>\n<p>The second interesting thing is that <code class=\"language-text\">frontmatter___author</code> is not a string, but rather a GraphQL enum. You can verify this by using intellisense in GraphiQL to see all possible values. This implies that Gatsby has generated all possible field names. Which is true! To do this, we create an <a href=\"/docs/schema-gql-type#gqltype-creation\">exampleValue</a> and then use the <a href=\"https://www.npmjs.com/package/flat\">flat</a> library to flatten the nested object into string keys, using <code class=\"language-text\">___</code> delimiters. This is handled by the <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/data-tree-utils.js#L277\">data-tree-utils.js/buildFieldEnumValues</a> function.</p>\n<p>Note, the same enum mechanism is used for creation of <code class=\"language-text\">distinct</code> fields</p>\n<h4 id=\"group-resolver\"><a href=\"#group-resolver\" aria-label=\"group resolver permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Group Resolver</h4>\n<p>The resolver for the Group type is created in <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/build-connection-fields.js#L57\">build-connection-fields.js</a>. It operates on the result of the core connection query (e.g <code class=\"language-text\">allMarkdownRemark</code>), which is a <code class=\"language-text\">Connection</code> object with edges. From these edges, we retrieve all the nodes (each edge has a <code class=\"language-text\">node</code> field). And now we can use lodash to group those nodes by the fieldname argument (e.g <code class=\"language-text\">field: frontmatter___author</code>).</p>\n<p>If sorting was specified (<a href=\"#sorting\">see below</a>), we sort the groups by fieldname, and then apply any <code class=\"language-text\">skip/limit</code> arguments using the <a href=\"https://www.npmjs.com/package/graphql-skip-limit\">graphql-skip-limit</a> library. Finally we are ready to fill in our <code class=\"language-text\">field</code>, <code class=\"language-text\">fieldValue</code>, and <code class=\"language-text\">totalCount</code> fields on each group, and we can return our resolved node.</p>\n<h3 id=\"input-filter-creation\"><a href=\"#input-filter-creation\" aria-label=\"input filter creation permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Input filter creation</h3>\n<p>Just like in <a href=\"/docs/schema-input-gql\">gql type input filters</a>, we must generate standard input filters on our connectiontype arguments. As a reminder, these allow us to query any fields by predicates such as <code class=\"language-text\">{ eq: &quot;value&quot; }</code>, or <code class=\"language-text\">{ glob: &quot;foo*&quot; }</code>. This is covered by the same functions (in <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/infer-graphql-input-fields.js\">infer-graphql-object-type.js</a>), except that we’re passing in Connection types instead of basic types. The only difference is that we use the <code class=\"language-text\">sort</code> field (<a href=\"#sorting\">see below</a>)</p>\n<h3 id=\"sorting\"><a href=\"#sorting\" aria-label=\"sorting permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sorting</h3>\n<p>A <code class=\"language-text\">sort</code> argument can be added to the <code class=\"language-text\">Connection</code> type (not the <code class=\"language-text\">GroupConnection</code> type). You can sort by any (possibly nested) field in the connection results. These are enums that are created via the same mechanism described in <a href=\"#field-enum-value\">enum fields</a>. Except that the inference of these enums occurs in <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/infer-graphql-input-fields.js#L302\">infer-graphql-input-type.js</a>.</p>\n<p>The Sort Input Type itself is created in <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/build-node-connections.js#L49\">build-node-connections.js</a> and implemented by <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/create-sort-field.js\">create-sort-field.js</a>. The actual sorting occurs in run-sift (below).</p>\n<h3 id=\"connection-resolver-sift\"><a href=\"#connection-resolver-sift\" aria-label=\"connection resolver sift permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Connection Resolver (sift)</h3>\n<p>Finally, we’re ready to define the resolver for our Connection type (in <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/build-node-connections.js#L65\">build-node-connections.js</a>). This is where we come up with the name <code class=\"language-text\">all${type}</code> (e.g <code class=\"language-text\">allMarkdownRemark</code>) that is so common in Gatsby queries. The resolver is fairly simple. It uses the <a href=\"https://www.npmjs.com/package/sift\">sift.js</a> library to query across all nodes of the same type in redux. The big difference is that we supply the <code class=\"language-text\">connection: true</code> parameter to <code class=\"language-text\">run-sift.js</code> which is where sorting, and pagination is actually executed. See <a href=\"/docs/schema-sift\">Querying with Sift</a> for how this actually works.</p>"}