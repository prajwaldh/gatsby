{"expireTime":9007200804686346000,"key":"transformer-remark-markdown-html-6140608acf5828b63ff04628bb3ce73e-gatsby-remark-graphvizgatsby-remark-code-titlesgatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<h2 id=\"summary\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h2>\n<p>Gatsby stores all data loaded during the source-nodes phase in Redux. And it allows you to write GraphQL queries to query that data. But Redux is a plain JavaScript object store. So how does Gatsby query over those nodes using the GraphQL query language?</p>\n<p>The answer is that it uses the <a href=\"https://github.com/crcn/sift.js/tree/master\">sift.js</a> library. It is a port of the MongoDB query language that works over plain JavaScript objects. It turns out that mongo’s query language is very compatible with GraphQL.</p>\n<p>Most of the logic below is in the <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/run-sift.js\">run-sift.js</a> file, which is called from the <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/build-node-types.js#L191\">ProcessedNodeType <code class=\"language-text\">resolve()</code></a> function.</p>\n<h2 id=\"processednodetype-resolve-function\"><a href=\"#processednodetype-resolve-function\" aria-label=\"processednodetype resolve function permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ProcessedNodeType Resolve Function</h2>\n<p>Remember, at the point this resolve function is created, we have been iterating over all the distinct <code class=\"language-text\">node.internal.type</code>s in the redux <code class=\"language-text\">nodes</code> namespace. So for instance we might be on the <code class=\"language-text\">MarkdownRemark</code> type. Therefore the <code class=\"language-text\">resolve()</code> function closes over this type name and has access to all the nodes of that type.</p>\n<p>The <code class=\"language-text\">resolve()</code> function calls <code class=\"language-text\">run-sift.js</code>, and provides it with the following arguments:</p>\n<ul>\n<li>GraphQLArgs (as JavaScript object). Within a filter. E.g <code class=\"language-text\">wordcount: { paragraphs: { eq: 4 } }</code></li>\n<li>All nodes in redux of this type. E.g where <code class=\"language-text\">internal.type == MmarkdownRemark&#39;</code></li>\n<li>Context <code class=\"language-text\">path</code>, if being called as part of a <a href=\"/docs/query-execution/#query-queue-execution\">page query</a></li>\n<li>typeName. E.g <code class=\"language-text\">markdownRemark</code></li>\n<li>gqlType. See <a href=\"/docs/schema-gql-type\">more on gqlType</a></li>\n</ul>\n<p>For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">runSift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  args<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    filter<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// Exact args from GraphQL Query</span>\n      wordcount<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        paragraphs<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n          eq<span class=\"token punctuation\">:</span> <span class=\"token number\">4</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  nodes<span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>latestNodes<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  path<span class=\"token punctuation\">:</span> context<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">,</span> <span class=\"token comment\">// E.g /blogs/my-blog</span>\n  typeName<span class=\"token punctuation\">:</span> <span class=\"token template-string\"><span class=\"token string\">`markdownRemark`</span></span><span class=\"token punctuation\">,</span>\n  type<span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>gqlType<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"run-siftjs\"><a href=\"#run-siftjs\" aria-label=\"run siftjs permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Run-sift.js</h2>\n<p>This file converts GraphQL Arguments into sift queries and applies them to the collection of all nodes of this type. The rough steps are:</p>\n<ol>\n<li>Convert query args to sift args</li>\n<li>Drop leaves from args</li>\n<li>Resolve inner query fields on all nodes</li>\n<li>Track newly realized fields</li>\n<li>Run sift query on all nodes</li>\n<li>Create Page dependency if required</li>\n</ol>\n<h3 id=\"1-convert-query-args-to-sift-args\"><a href=\"#1-convert-query-args-to-sift-args\" aria-label=\"1 convert query args to sift args permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Convert query args to sift args</h3>\n<p>Sift expects all field names to be prepended by a <code class=\"language-text\">$</code>. The <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/run-sift.js#L58\">siftify-args</a> function takes care of this. It descends the args tree, performing the following transformations for each field key/value scenario.</p>\n<ul>\n<li>field key is<code class=\"language-text\">elemMatch</code>? Change to <code class=\"language-text\">$elemMatch</code>. Recurse on value object</li>\n<li>field value is regex? Apply regex cleaning</li>\n<li>field value is glob, use <a href=\"https://www.npmjs.com/package/minimatch\">minimatch</a> library to convert to Regex</li>\n<li>normal value, prepend <code class=\"language-text\">$</code> to field name.</li>\n</ul>\n<p>So, the above query would become:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  <span class=\"token template-string\"><span class=\"token string\">`$wordcount`</span></span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token template-string\"><span class=\"token string\">`$paragraphs`</span></span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token template-string\"><span class=\"token string\">`$eq`</span></span><span class=\"token punctuation\">:</span> <span class=\"token number\">4</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"2-drop-leaves-eg-eq-4-from-args\"><a href=\"#2-drop-leaves-eg-eq-4-from-args\" aria-label=\"2 drop leaves eg eq 4 from args permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Drop leaves (e.g <code class=\"language-text\">{eq: 4}</code>) from args</h3>\n<p>To assist in step 3, we create a version of the siftified args called <code class=\"language-text\">fieldsToSift</code> that has all leaves of the args tree replaced with boolean <code class=\"language-text\">true</code>. This is handled by the <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/run-sift.js#L84\">extractFieldsToSift</a> function. <code class=\"language-text\">fieldsToSift</code> would look like this after the function is applied:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  <span class=\"token template-string\"><span class=\"token string\">`wordcount`</span></span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token template-string\"><span class=\"token string\">`paragraphs`</span></span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"3-resolve-inner-query-fields-on-all-nodes\"><a href=\"#3-resolve-inner-query-fields-on-all-nodes\" aria-label=\"3 resolve inner query fields on all nodes permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Resolve inner query fields on all nodes</h3>\n<p>Step 4 will perform the actual sift query over all the nodes, returning the first one that matches the query. But we must remember that the nodes that are in redux only include data that was explicitly created by their source or transform plugins. If instead of creating a data field, a plugin used <code class=\"language-text\">setFieldsOnGraphQLNodeType</code> to define a custom field, then we have to manually call that field’s resolver on each node. The args in step 2 is a great example. The <code class=\"language-text\">wordcount</code> field is defined by the <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby-transformer-remark/src/extend-node-type.js#L416\">gatsby-transformer-remark</a> plugin, rather than created during the creation of the remark node.</p>\n<p>The <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/run-sift.js#L168\">nodesPromise</a> function iterates over all nodes of this type. Then, for each node, <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/run-sift.js#L112\">resolveRecursive</a> descends the <code class=\"language-text\">siftToFields</code> tree, getting the field name, and then finding its gqlType, and then calling that type’s <code class=\"language-text\">resolve</code> function manually. E.g, for the above example, we would find the gqlField for <code class=\"language-text\">wordcount</code> and call its resolve field:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">markdownRemarkGqlType<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> fieldName<span class=\"token punctuation\">:</span> <span class=\"token template-string\"><span class=\"token string\">`wordcount`</span></span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Note that the graphql-js library has NOT been invoked yet. We’re instead calling the appropriate gqlType resolve function manually.</p>\n<p>The resolve method in this case would return a paragraph node, which also needs to be properly resolved. So We descend the <code class=\"language-text\">fieldsToSift</code> arg tree and perform the above operation on the paragraph node (using the found paragraph gqlType).</p>\n<p>After <code class=\"language-text\">resolveRecursive</code> has finished, we will have “realized” all the query fields in each node, giving us confidence that we can perform the query with all the data being there.</p>\n<h3 id=\"4-track-newly-realized-fields\"><a href=\"#4-track-newly-realized-fields\" aria-label=\"4 track newly realized fields permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Track newly realized fields</h3>\n<p>Since new fields on the node may have been created in this process, we call <code class=\"language-text\">trackInlineObjectsInRootNode()</code> to track these new objects. See <a href=\"/docs/node-tracking/\">Node Tracking</a> docs for more.</p>\n<h3 id=\"5-run-sift-query-on-all-nodes\"><a href=\"#5-run-sift-query-on-all-nodes\" aria-label=\"5 run sift query on all nodes permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Run sift query on all nodes</h3>\n<p>Now that we’ve realized all fields that need to be queried, on all nodes of this type, we are finally ready to apply the sift query. This step is handled by <a href=\"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/src/schema/run-sift.js#L214\">tempPromise</a>. It simply concatenates all the top level objects in the args tree together with a sift <code class=\"language-text\">$and</code> expression, and then iterates over all nodes returning the first one that satisfies the sift expression.</p>\n<p>In the case that <code class=\"language-text\">connection === true</code> (argument passed to run-sift), then instead of just choosing the first argument, we will select ALL nodes that match the sift query. If the GraphQL query specified <code class=\"language-text\">sort</code>, <code class=\"language-text\">skip</code>, or <code class=\"language-text\">limit</code> fields, then we use the <a href=\"https://www.npmjs.com/package/graphql-skip-limit\">graphql-skip-limit</a> library to filter down to the appropriate results. See <a href=\"/docs/schema-connections\">Schema Connections</a> for more info.</p>\n<h3 id=\"6-create-page-dependency-if-required\"><a href=\"#6-create-page-dependency-if-required\" aria-label=\"6 create page dependency if required permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. Create Page dependency if required</h3>\n<p>Assuming we find a node (or multiple if <code class=\"language-text\">connection</code> === true), we finish off by recording the page that initiated the query (in the <code class=\"language-text\">path</code> field) depends on the found node. More on this in <a href=\"/docs/page-node-dependencies/\">Page -> Node Dependencies</a>.</p>\n<h2 id=\"note-about-plugin-resolver-side-effects\"><a href=\"#note-about-plugin-resolver-side-effects\" aria-label=\"note about plugin resolver side effects permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Note about plugin resolver side effects</h2>\n<p>As <a href=\"#3-resolve-inner-query-fields-on-all-nodes\">mentioned above</a>, <code class=\"language-text\">run-sift</code> must “realize” all query fields before querying over them. This involves calling the resolvers of custom plugins on <strong>each node of that type</strong>. Therefore, if a resolver performs side effects, then these will be triggered, regardless of whether the field result actually matches the query.</p>"}