{"expireTime":9007200804686411000,"key":"transformer-remark-markdown-html-671cd48cdbe1f99cc7d0d1cad7a8069a-gatsby-remark-graphvizgatsby-remark-code-titlesgatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<p>In this post, I will talk about static site generators — how they have evolved\nand why I switched from a <a href=\"https://ghost.org\">Ghost</a> powered site to\n<a href=\"/\">Gatsby.js</a>, a modern static site generator.</p>\n<h2 id=\"static-site-generators-as-we-know-them\"><a href=\"#static-site-generators-as-we-know-them\" aria-label=\"static site generators as we know them permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Static site generators as we know them</h2>\n<p>Jekyll, my tool of preference for quite a few years, helped me build\n<a href=\"http://devastation.tv\">robust</a> <a href=\"http://devitconf.org\">professional</a>\n<a href=\"http://skgtech.io\">web presences</a> that content managers can update with the\nclick of a button. It helped me quickly move a project of mine from idea to\nproduction by creating a landing page very fast.</p>\n<p>Static site generators like Jekyll all work pretty similarly:</p>\n<ul>\n<li>Describe your content in some common templating language (<a href=\"http://pugjs.org\">Pug</a>,\n<a href=\"http://handlebarsjs.com\">Handlebars</a>, etc)</li>\n<li>While in development, start a local web server and add file “watchers” that\nwill listen for content changes and re-render the site</li>\n<li>Finally, render the whole site in static HTML and deploy. The generator will\ncombine your files and produce a well formed HTML content.</li>\n</ul>\n<p>Let’s say you navigate to the good old site example.com:</p>\n<ul>\n<li>The browser requests the page at example.com</li>\n<li>The server responds with the HTML content</li>\n<li>The browser renders the page and loads the asset related to the script tag</li>\n<li>JS will instruct the browser to manipulate the DOM, for example, to show a\n“welcome to this page” popup dialog.</li>\n</ul>\n<p>A caveat here is that you have to keep the client side logic separated from the\nbackend. The client side JS file that shows the modal dialog has nothing to do\nwith the PUG file you wrote and eventually became HTML. The client side logic\nonly manipulates directly the DOM.</p>\n<p>This architecture is fairly similar to a Wordpress site. A Wordpress engine also\ngenerates the HTML and serve it to the browser, after which the client side JS\nyou wrote kicks in and starts manipulating the DOM. Wordpress’s responses can be\ncached, of course, and served to the client; that setup effectively makes it\nanother static site generator with a GUI text editor.</p>\n<p>So to recap, the nice part of the static site setup is that your website is just\nstatic assets that are sitting somewhere ready to be served to user requests. No\nneed to maintain a runtime, a database, application code, or complex optimized\nweb servers.</p>\n<p>But the downside is you have to keep separate template files that will\neventually rendered as HTML on the browser, and JavaScript file that will\neventually manipulate that HTML again on the browser (and CSS assets too).</p>\n<h2 id=\"enter-the-new-world-order\"><a href=\"#enter-the-new-world-order\" aria-label=\"enter the new world order permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Enter the new world order</h2>\n<p>I <a href=\"https://kostasbariotis.com/hands-on-react-js/\">started experimenting</a> with\nReact two years ago. It came with so many features out of the box that no one\never has seen except the guys working internally on Facebook’s codebase. But the\nthing that stood out immediately was the way which React was handling the DOM,\naka the Virtual DOM.</p>\n<p>To change a page’s display, you have to change the DOM — but changing the DOM\nis computationally expensive, so — slow. React is smart, and analyzes the\nchanges you want to make so it applies only required changes, thus making the\nrendering much faster.</p>\n<p>If you use React with\n<a href=\"https://facebook.github.io/react/docs/react-dom-server.html\">server-side rendering</a>,\nyour flow looks something like this:</p>\n<ul>\n<li>A browser requests a page</li>\n<li>The server responds with static HTML</li>\n<li>The browser immediately renders the page so the user can see it</li>\n<li>The browser loads additional JS in the background</li>\n<li>The client takes some action, like navigating to a different route.</li>\n<li>The browser uses the additional JS to handle this action.</li>\n</ul>\n<p>On your end, the development flow looks:</p>\n<ul>\n<li>Describe your content in React.js Components</li>\n<li>During development, write code like a boss (hot reloading, modularized code,\nwebpack plugins, etc…)</li>\n<li>Use React.js Server Side Rendering API to convert this code to static HTML\ncontent, and JavaScript code, on your server</li>\n</ul>\n<p>It’s really that easy? Well, sort of.</p>\n<p>There is the need for a strong abstraction that will…</p>\n<ul>\n<li>track your links across your components</li>\n<li>parse content written in another format, like blog posts written in Markdown</li>\n<li>generate code that will not bloat the client and will efficiently serve the\ncontent to the user.</li>\n</ul>\n<p>Thankfully, there are a few projects that took the initiative on this:\n<a href=\"/\">Gatsby.js</a>, <a href=\"https://phenomic.io\">Phenomic</a>, and\n<a href=\"https://nextein.now.sh\">nextein</a>.</p>\n<p>At the time that I started following them, early 2017, all of them were in a\nvery early stage and none of them could generate my site’s content the way I\nwanted.</p>\n<p>I wanted to make the generated site, exactly like the old one, in terms of both\nuser experience and keeping my old routes and paths so I don’t have weird 404s.</p>\n<p>Gatsby came with client side routing out of the box and an extensive API that\nyou can use to generate your content exactly like you need. And once Gatsby.js\nhit major version 1, I started using it and the result…you can\n<a href=\"https://kostasbariotis.com/\">look at it</a>!</p>\n<h2 id=\"what-exactly-am-i-looking-at\"><a href=\"#what-exactly-am-i-looking-at\" aria-label=\"what exactly am i looking at permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What exactly am I looking at?</h2>\n<p>First, if you navigate around my blog (or around this site!), you will notice\nthat the browser doesn’t fully re-render the site. Gatsby will generate a JSON\nfile for each route, so the browser can request only that file and React.js will\nrender only the appropriate components.</p>\n<p>(Previously to do this required a lot of customization — I was using a\ntechnique called\n<a href=\"https://github.com/kbariotis/kostasbariotis.com__ghost-theme/blob/master/src/js/app.js#L11\">pjax</a>\nto create the same effect. While it looked the same, it was more hack-ish;\nGatsby provides this out of the box)</p>\n<p>Second, you can take a look at the\n<a href=\"https://github.com/kbariotis/kostasbariotis.com\">source code</a>. Let me give you\na sense of how this site is being generated. You can find all my blog posts and\nthe main pages(<code class=\"language-text\">/</code>, <code class=\"language-text\">/about</code>, <code class=\"language-text\">/drafts</code>) of this site at\n<a href=\"https://github.com/kbariotis/kostasbariotis.com/tree/master/src/pages\"><code class=\"language-text\">/src/pages</code></a>.\nCommon components can be found at\n<a href=\"https://github.com/kbariotis/kostasbariotis.com/tree/master/src/components\"><code class=\"language-text\">/src/components</code></a>.\nAt\n<a href=\"https://github.com/kbariotis/kostasbariotis.com/tree/master/gatsby-node.js\"><code class=\"language-text\">/gatsby-node.js</code></a>\nyou can find the route it takes in order to render the site. First, it loads all\nposts using the GraphQL api which queries all <code class=\"language-text\">.md</code> files. Then it creates a\npage for each one, using the\n<a href=\"https://github.com/kbariotis/kostasbariotis.com/tree/master/src/templates/blog-post.js\"><code class=\"language-text\">/src/templates/blog-post.js</code></a>\ntemplate and before that it creates a page, with pagination, for all posts and\ntags again using the appropriate template file.</p>\n<p>During development, Gatsby will generate all of these in memory and fire up a\ndevelopment server that I can use to preview my site.</p>\n<p>You can try it yourself by cloning the\n<a href=\"https://github.com/kbariotis/kostasbariotis.com\">source code</a> and after\ninstalling dependencies, run:</p>\n<ul>\n<li><code class=\"language-text\">npm run develop</code> to fire up the development server</li>\n<li><code class=\"language-text\">npm run build</code> to build the site (check the <code class=\"language-text\">/public</code> folder after it’s done)</li>\n</ul>\n<h2 id=\"an-alternative-to-html-caching\"><a href=\"#an-alternative-to-html-caching\" aria-label=\"an alternative to html caching permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>An alternative to HTML caching</h2>\n<p>Now let’s bring these threads together. Let’s say you have a Wordpress site.\nYou’re caching the content, which is nice for performance, but you’re building\non it now and want to move to a more modern web development experience.</p>\n<p>One path is the one I took — for the last three years, I was using a similar\nsystem called <a href=\"https://ghost.org\">Ghost</a>. While it served me well, I really got\ntired of updating it, ssh-ing to the server, doing migrations and doing other\nops required by such a stack. (There are paid hosting options, of course, but\nthat comes with a different set of problems). So I switched to Gatsby.</p>\n<p>Another option, if you want to keep Wordpress’ Admin UI is to maintain your\ncontent, is to separate the backend from the frontend.</p>\n<p>Imagine that instead of having <a href=\"https://memcached.org/\">memcached</a> caching your\nHTML in front of your WordPress site, you trigger a hook each time your database\nchanges that will re-generate the frontend using Gatsby’s\n<a href=\"/packages/gatsby-source-wordpress/\">Wordpress plugin</a>. Yes, Gatsby supports\nmultiple backend sources to load your content. Instead of storing them inside\nyour version control like me, you can just as well load them from your\nWordpress’s MySQL database.</p>\n<p>To conclude, Gatsby will allow us to:</p>\n<ul>\n<li>serve static content without maintaining complex stacks</li>\n<li>keep a clear separation between content and the presentation layer</li>\n<li>have cool features like client side routing and hot reload on development, out\nof the box</li>\n<li>reuse the same code that is being used to generate the backend content at our\nvisitors’ browsers</li>\n</ul>\n<p>I hope you will experiment with Gatsby, and let me know what you think!</p>"}