'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Annotation = require('../annotation');
var Header = require('../httpHeaders');
var InetAddress = require('../InetAddress');
var TraceId = require('../tracer/TraceId');
var parseRequestUrl = require('../parseUrl');

var _require = require('../option'),
    Some = _require.Some,
    None = _require.None;

function stringToBoolean(str) {
  return str === '1' || str === 'true';
}

function stringToIntOption(str) {
  try {
    return new Some(parseInt(str));
  } catch (err) {
    return None;
  }
}

function containsRequiredHeaders(readHeader) {
  return readHeader(Header.TraceId) !== None && readHeader(Header.SpanId) !== None;
}

function requiredArg(name) {
  throw new Error('HttpServerInstrumentation: Missing required argument ' + name + '.');
}

var HttpServerInstrumentation = function () {
  function HttpServerInstrumentation(_ref) {
    var _ref$tracer = _ref.tracer,
        tracer = _ref$tracer === undefined ? requiredArg('tracer') : _ref$tracer,
        _ref$serviceName = _ref.serviceName,
        serviceName = _ref$serviceName === undefined ? tracer.localEndpoint.serviceName : _ref$serviceName,
        host = _ref.host,
        _ref$port = _ref.port,
        port = _ref$port === undefined ? requiredArg('port') : _ref$port;

    _classCallCheck(this, HttpServerInstrumentation);

    this.tracer = tracer;
    this.serviceName = serviceName;
    this.host = host && new InetAddress(host);
    this.port = port;
  }

  _createClass(HttpServerInstrumentation, [{
    key: '_createIdFromHeaders',
    value: function _createIdFromHeaders(readHeader) {
      if (containsRequiredHeaders(readHeader)) {
        var spanId = readHeader(Header.SpanId);
        return spanId.map(function (sid) {
          var traceId = readHeader(Header.TraceId);
          var parentSpanId = readHeader(Header.ParentSpanId);
          var sampled = readHeader(Header.Sampled);
          var flags = readHeader(Header.Flags).flatMap(stringToIntOption).getOrElse(0);
          return new TraceId({
            traceId: traceId,
            parentId: parentSpanId,
            spanId: sid,
            sampled: sampled.map(stringToBoolean),
            flags: flags
          });
        });
      } else {
        if (readHeader(Header.Flags) !== None || readHeader(Header.Sampled) !== None) {
          var sampled = readHeader(Header.Sampled) === None ? None : readHeader(Header.Sampled).map(stringToBoolean);
          var flags = readHeader(Header.Flags).flatMap(stringToIntOption).getOrElse(0);
          return new Some(this.tracer.createRootId(sampled, flags === 1));
        } else {
          return new Some(this.tracer.createRootId());
        }
      }
    }
  }, {
    key: 'recordRequest',
    value: function recordRequest(method, requestUrl, readHeader) {
      var _this = this;

      this._createIdFromHeaders(readHeader).ifPresent(function (id) {
        return _this.tracer.setId(id);
      });
      var id = this.tracer.id;

      var _parseRequestUrl = parseRequestUrl(requestUrl),
          path = _parseRequestUrl.path;

      this.tracer.recordServiceName(this.serviceName);
      this.tracer.recordRpc(method.toUpperCase());
      this.tracer.recordBinary('http.path', path);
      this.tracer.recordAnnotation(new Annotation.ServerRecv());
      this.tracer.recordAnnotation(new Annotation.LocalAddr({ host: this.host, port: this.port }));

      return id;
    }
  }, {
    key: 'recordResponse',
    value: function recordResponse(id, statusCode, error) {
      this.tracer.setId(id);
      this.tracer.recordBinary('http.status_code', statusCode.toString());
      if (error) {
        this.tracer.recordBinary('error', error.toString());
      } else if (statusCode < 200 || statusCode > 399) {
        this.tracer.recordBinary('error', statusCode.toString());
      }
      this.tracer.recordAnnotation(new Annotation.ServerSend());
    }
  }]);

  return HttpServerInstrumentation;
}();

module.exports = HttpServerInstrumentation;